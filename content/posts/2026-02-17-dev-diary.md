---
title: "Forty-Three Tickets and a Cancer App"
date: 2026-02-17
description: "Launched an entire cancer care coordination app, shipped a 24-ticket production release, ran a 10-ticket autonomous chain, audited email infrastructure across 16 senders, and still had time to set up a community forum and start a camera dashboard project."
draft: true
tags: ["dev-diary", "claude-code", "supabase", "typescript", "deployment"]
---

I was staring at the CureCancerMagic care team invite system when I realized this was the ninth ticket in a row for an app that didn't exist last week. Care team invites, email ingestion, AI-powered summarization, document management, notifications, reporting, mobile optimization, multi-case support. Each one its own branch, its own migration, its own set of RLS policies. By the time I shipped the last fix - a migration that almost overwrote PostgREST's schema list - the app was real.

That was maybe a third of the day.

---

## Things We Learned Today

The email infrastructure audit produced the most interesting finding. I ran `/start INT-247` to review every automated email sender across the platform - all 16 of them across 6 apps. CureCancerMagic, the newest app, was the *only* one correctly using the platform's `sendEmail()` abstraction. All three of its email senders go through it. Meanwhile, 13 of the other 16 senders create their own `new Resend()` client, bypassing suppression checking and rate-limit retry logic.

The pattern is clear: abstractions built after the first few apps exist tend to be adopted only by new apps. Older apps keep their original implementations. I'm calling this the "last-built-first-right" pattern. It suggests that platform-level refactoring should prioritize migrating older apps rather than assuming they'll catch up organically. The audit also found 4 distinct patterns for resolving "from" addresses - branding lookup, env vars, different env vars, and hardcoded strings. Each service was built in isolation before a canonical pattern existed.

That audit turned into 26 Linear tickets across 4 teams. The parent ticket became a container whose children represent the actual work.

---

TypeScript's `satisfies` operator threw a curveball during config consolidation. When `@platform/ui` runs its own `tsc --noEmit`, it can't resolve `@platform/config` - a pre-existing TS2307. That makes `AppId` resolve to `any`. With `as const satisfies Record<any, object>`, TypeScript narrows the const assertion's type differently than with plain `as const`, causing TS7053 indexing errors. The `exactOptionalPropertyTypes` flag adds another layer: constructing objects from JSON imports where `prop?: string` means the property must be *absent* or `string` - explicitly setting `previewUrl: undefined` gets rejected. The fix is conditional spread: `...(p.previewUrl ? { previewUrl: p.previewUrl } : {})`.

Both gotchas share a theme. TypeScript's strict mode features create surprising interactions when combined with cross-package type resolution.

---

Google OAuth has a multi-account trap I hadn't hit before. Supabase's `signInWithOAuth` with `provider: "google"` passes no `queryParams` by default. That means Google auto-selects whichever account is active in the Chrome profile. When the OAuth app's consent screen is set to "Internal" - restricting to the Workspace org - the auto-selected wrong account hits `Error 403: org_internal`. The fix is one line: `queryParams: { prompt: "select_account" }`. Forces the account picker so users can select their org account even when a personal account is the default Chrome session.

---

Freshell's pane architecture taught me something about recursive data structures. The pane system uses an immutable tree - `PaneNode` is either a leaf or a split. Adding horizontal/vertical split required changing only the tree surgery point. The `addPane` reducer wraps the active leaf in a new split node with a configurable `direction` field. Because the tree is recursively rendered by `SplitView`, the new direction just works without touching the rendering pipeline. The UI change - single FAB to two-button stack - was more invasive than the data model change.

When adding a Redux slice for the activity panel, I rediscovered the defensive selector pattern. Components that select from a new slice crash in tests that create partial stores. The fix is `s.slice?.visibility ?? {}` - making components tolerant of missing slices. One line versus updating dozens of test store configurations.

---

## Things We Did Today

The CureCancerMagic launch was the centerpiece. Nine tickets took it from database schema to a production app with care team invites, inbound email processing, AI-powered email summarization, document management, a notification system, reporting and export, mobile-responsive layouts, and multi-case support with a case switcher. The RLS policies were the trickiest part - an infinite recursion bug in `care_team_members` required careful policy restructuring, and the migration that added `curecancermagic` to PostgREST's schema list needed the read-then-append pattern to avoid overwriting all other schemas.

The IntensityMagic admin dashboard got a complete overhaul. A consolidated infrastructure dashboard replaced scattered tool pages. Time-period selectors, extended health checks for all 15 services, dedicated Stripe and Linear pages, and standardized headers across every service page. The config consolidation work (INT-253 through INT-256) eliminated hardcoded app lists by deriving everything from `@platform/config` - so adding a new app to the platform is now a single-file change that the TypeScript compiler enforces.

I ran a 10-ticket autonomous chain (INT-258 through INT-267) for IntensityMagic UI consolidation. Each ticket independently promoted app-specific code to `@platform/ui` or shared utils. Pagination, CollapsibleCard, ServicePageLayout - all extracted and promoted. The chain completed 10/10 with zero failures. Plans auto-approved, user testing skipped, commits automatic between tickets.

Production release #185 shipped 24 tickets across 6 teams. The bundle size check timed out - adding CureCancerMagic pushed it past GitHub's time limit - but that's a non-required check. GitHub's `UNSTABLE` merge state means optional checks failed while required checks passed. The distinction matters for automated pipelines.

On the community side, I published a [Supermemory evaluation](https://adventuresinclaude.ai/posts/2026-02-17-supermemory-evaluation/) and restructured the blog draft pipeline from 4 technical sections to 3 narrative ones. Audited Discourse plugins on the Adventures in Claude forum - disabled 7 unused plugins, freeing 64 MB of container memory. Fixed SVG branding uploads, moved secrets to systemd EnvironmentFiles, and set up RSS automation.

Freshell got horizontal/vertical split support and a structured activity panel sidebar. Overwatch - a new camera dashboard project - got its initial Pi infrastructure config with Docker, Cloudflare Tunnel, and go2rtc.

---

## Fun Things to Try

The single landing host pattern is worth exploring further. One Vercel project serving all app landing pages with custom domain aliases, powered by Hugo static output. Instead of N Vercel projects for N apps, one project serves everything. Works because Hugo output is pure static files with no server runtime. The trade-off is losing per-app deployment isolation, but immutable deployments give you instant rollback.

Ring buffers for UI event panels. Freshell's activity panel uses `events[eventStart] = newEvent; eventStart = (eventStart + 1) % MAX` for O(1) insertion with bounded memory. No GC pauses, no array copying, no periodic truncation. Worth adopting anywhere you're showing a live stream of events in a fixed-size container.

The voice learning feedback loop built into `/blogaic-post` - diffing the user's edits against the last commit at publish time to automatically improve the voice profile. Every publish becomes calibration data. The highest-signal data for voice matching is what the user *changed*, not what they kept.

---

*Generated from daily notes. Review and edit before publishing.*
